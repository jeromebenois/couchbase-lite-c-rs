/* automatically generated by rust-bindgen */

pub type __darwin_size_t = ::std::os::raw::c_ulong;
#[doc = " Error domains, serving as namespaces for numeric error codes."]
pub type CBLErrorDomain = u32;
#[doc = " A struct holding information about an error. It's declared on the stack by a caller, and"]
#[doc = "its address is passed to an API function. If the function's return value indicates that"]
#[doc = "there was an error (usually by returning NULL or false), then the CBLError will have been"]
#[doc = "filled in with the details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLError {
    #[doc = "< Domain of errors; a namespace for the `code`."]
    pub domain: CBLErrorDomain,
    #[doc = "< Error code, specific to the domain. 0 always means no error."]
    pub code: i32,
    pub internal_info: i32,
}
#[test]
fn bindgen_test_layout_CBLError() {
    assert_eq!(::core::mem::size_of::<CBLError>(), 12usize, concat!("Size of: ", stringify!(CBLError)));
    assert_eq!(
        ::core::mem::align_of::<CBLError>(),
        4usize,
        concat!("Alignment of ", stringify!(CBLError))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLError>())).domain as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CBLError), "::", stringify!(domain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLError>())).code as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(CBLError), "::", stringify!(code))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLError>())).internal_info as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CBLError), "::", stringify!(internal_info))
    );
}
#[doc = " A date/time representation used for document expiration (and in date/time queries.)"]
#[doc = "Measured in milliseconds since the Unix epoch (1/1/1970, midnight UTC.)"]
pub type CBLTimestamp = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLDatabase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLDocument {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLBlob {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLQuery {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLResultSet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLReplicator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLListenerToken {
    _unused: [u8; 0],
}
#[doc = " Flags for how to open a database."]
pub type CBLDatabaseFlags = u32;
#[doc = " Encryption algorithms (available only in the Enterprise Edition)."]
pub type CBLEncryptionAlgorithm = u32;
#[doc = " Encryption key specified in a \\ref CBLDatabaseConfiguration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLEncryptionKey {
    #[doc = "< Encryption algorithm"]
    pub algorithm: CBLEncryptionAlgorithm,
    #[doc = "< Raw key data"]
    pub bytes: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_CBLEncryptionKey() {
    assert_eq!(
        ::core::mem::size_of::<CBLEncryptionKey>(),
        36usize,
        concat!("Size of: ", stringify!(CBLEncryptionKey))
    );
    assert_eq!(
        ::core::mem::align_of::<CBLEncryptionKey>(),
        4usize,
        concat!("Alignment of ", stringify!(CBLEncryptionKey))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLEncryptionKey>())).algorithm as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CBLEncryptionKey), "::", stringify!(algorithm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLEncryptionKey>())).bytes as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(CBLEncryptionKey), "::", stringify!(bytes))
    );
}
#[doc = " Database configuration options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLDatabaseConfiguration {
    #[doc = "< The parent directory of the database"]
    pub directory: *const ::std::os::raw::c_char,
    #[doc = "< Options for opening the database"]
    pub flags: CBLDatabaseFlags,
    #[doc = "< The database's encryption key (if any)"]
    pub encryptionKey: CBLEncryptionKey,
}
#[test]
fn bindgen_test_layout_CBLDatabaseConfiguration() {
    assert_eq!(
        ::core::mem::size_of::<CBLDatabaseConfiguration>(),
        48usize,
        concat!("Size of: ", stringify!(CBLDatabaseConfiguration))
    );
    assert_eq!(
        ::core::mem::align_of::<CBLDatabaseConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(CBLDatabaseConfiguration))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLDatabaseConfiguration>())).directory as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CBLDatabaseConfiguration), "::", stringify!(directory))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLDatabaseConfiguration>())).flags as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CBLDatabaseConfiguration), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLDatabaseConfiguration>())).encryptionKey as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(CBLDatabaseConfiguration), "::", stringify!(encryptionKey))
    );
}
extern "C" {
    #[doc = " Opens a database, or creates it if it doesn't exist yet, returning a new \\ref CBLDatabase"]
    #[doc = "instance."]
    #[doc = "It's OK to open the same database file multiple times. Each \\ref CBLDatabase instance is"]
    #[doc = "independent of the others (and must be separately closed and released.)"]
    #[doc = "@param name  The database name (without the \".cblite2\" extension.)"]
    #[doc = "@param config  The database configuration (directory and encryption option.)"]
    #[doc = "@param error  On failure, the error will be written here."]
    #[doc = "@return  The new database object, or NULL on failure."]
    pub fn CBLDatabase_Open(name: *const ::std::os::raw::c_char, config: *const CBLDatabaseConfiguration, error: *mut CBLError) -> *mut CBLDatabase;
}
extern "C" {
    #[doc = " Closes an open database."]
    pub fn CBLDatabase_Close(arg1: *mut CBLDatabase, arg2: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Closes and deletes a database. If there are any other connections to the database,"]
    #[doc = "an error is returned."]
    pub fn CBLDatabase_Delete(arg1: *mut CBLDatabase, arg2: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Compacts a database file."]
    pub fn CBLDatabase_Compact(arg1: *mut CBLDatabase, arg2: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Begins a batch operation, similar to a transaction. You **must** later call \\ref"]
    #[doc = "CBLDatabase_EndBatch to end (commit) the batch."]
    #[doc = "@note  Multiple writes are much faster when grouped inside a single batch."]
    #[doc = "@note  Changes will not be visible to other CBLDatabase instances on the same database until"]
    #[doc = "the batch operation ends."]
    #[doc = "@note  Batch operations can nest. Changes are not committed until the outer batch ends."]
    pub fn CBLDatabase_BeginBatch(arg1: *mut CBLDatabase, arg2: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Ends a batch operation. This **must** be called after \\ref CBLDatabase_BeginBatch."]
    pub fn CBLDatabase_EndBatch(arg1: *mut CBLDatabase, arg2: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Returns the nearest future time at which a document in this database will expire,"]
    #[doc = "or 0 if no documents will expire."]
    pub fn CBLDatabase_NextDocExpiration(arg1: *mut CBLDatabase) -> CBLTimestamp;
}
extern "C" {
    #[doc = " Purges all documents whose expiration time has passed."]
    #[doc = "@param db  The database to purge"]
    #[doc = "@param error  On failure, the error will be written here."]
    #[doc = "@return  The number of documents purged, or -1 on error."]
    pub fn CBLDatabase_PurgeExpiredDocuments(db: *mut CBLDatabase, error: *mut CBLError) -> i64;
}
extern "C" {
    #[doc = " Returns the database's name."]
    pub fn CBLDatabase_Name(arg1: *const CBLDatabase) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the database's full filesystem path."]
    pub fn CBLDatabase_Path(arg1: *const CBLDatabase) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the number of documents in the database."]
    pub fn CBLDatabase_Count(arg1: *const CBLDatabase) -> u64;
}
extern "C" {
    #[doc = " Returns the database's configuration, as given when it was opened."]
    #[doc = "@note  The encryption key is not filled in, for security reasons."]
    pub fn CBLDatabase_Config(arg1: *const CBLDatabase) -> CBLDatabaseConfiguration;
}
#[doc = " A database change listener callback, invoked after one or more documents are changed on disk."]
#[doc = "@warning  By default, this listener may be called on arbitrary threads. If your code isn't"]
#[doc = "prepared for that, you may want to use \\ref CBLDatabase_BufferNotifications"]
#[doc = "so that listeners will be called in a safe context."]
#[doc = "@param context  An arbitrary value given when the callback was registered."]
#[doc = "@param db  The database that changed."]
#[doc = "@param numDocs  The number of documents that changed (size of the `docIDs` array)"]
#[doc = "@param docIDs  The IDs of the documents that changed, as a C array of `numDocs` C strings."]
pub type CBLDatabaseChangeListener = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        db: *const CBLDatabase,
        numDocs: ::std::os::raw::c_uint,
        docIDs: *mut *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Registers a database change listener callback. It will be called after one or more"]
    #[doc = "documents are changed on disk."]
    #[doc = "@param db  The database to observe."]
    #[doc = "@param listener  The callback to be invoked."]
    #[doc = "@param context  An opaque value that will be passed to the callback."]
    #[doc = "@return  A token to be passed to \\ref CBLListener_Remove when it's time to remove the"]
    #[doc = "listener."]
    pub fn CBLDatabase_AddChangeListener(
        db: *const CBLDatabase,
        listener: CBLDatabaseChangeListener,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut CBLListenerToken;
}
#[doc = " Callback indicating that the database (or an object belonging to it) is ready to call one"]
#[doc = "or more listeners. You should call \\ref CBLDatabase_SendNotifications at your earliest"]
#[doc = "convenience, in the context (thread, dispatch queue, etc.) you want them to run."]
#[doc = "@note  This callback is called _only once_ until the next time \\ref CBLDatabase_SendNotifications"]
#[doc = "is called. If you don't respond by (sooner or later) calling that function,"]
#[doc = "you will not be informed that any listeners are ready."]
#[doc = "@warning  This can be called from arbitrary threads. It should do as little work as"]
#[doc = "possible, just scheduling a future call to \\ref CBLDatabase_SendNotifications."]
pub type CBLNotificationsReadyCallback = ::core::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, db: *mut CBLDatabase)>;
extern "C" {
    #[doc = " Switches the database to buffered-notification mode. Notifications for objects belonging"]
    #[doc = "to this database (documents, queries, replicators, and of course the database) will not be"]
    #[doc = "called immediately; your \\ref CBLNotificationsReadyCallback will be called instead."]
    #[doc = "@param db  The database whose notifications are to be buffered."]
    #[doc = "@param callback  The function to be called when a notification is available."]
    #[doc = "@param context  An arbitrary value that will be passed to the callback."]
    pub fn CBLDatabase_BufferNotifications(db: *mut CBLDatabase, callback: CBLNotificationsReadyCallback, context: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Immediately issues all pending notifications for this database, by calling their listener"]
    #[doc = "callbacks."]
    pub fn CBLDatabase_SendNotifications(db: *mut CBLDatabase);
}
#[doc = " A simple reference to a block of memory. Does not imply ownership."]
#[doc = "(This is equivalent to the C++ class `slice`.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLSlice {
    pub buf: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_FLSlice() {
    assert_eq!(::core::mem::size_of::<FLSlice>(), 16usize, concat!("Size of: ", stringify!(FLSlice)));
    assert_eq!(::core::mem::align_of::<FLSlice>(), 8usize, concat!("Alignment of ", stringify!(FLSlice)));
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLSlice>())).buf as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FLSlice), "::", stringify!(buf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLSlice>())).size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(FLSlice), "::", stringify!(size))
    );
}
#[doc = " A block of memory returned from an API call. The caller takes ownership, and must call"]
#[doc = "FLSlice_Release (or FLSlice_Free) when done. The heap block may be shared with other users,"]
#[doc = "so it must not be modified."]
#[doc = "(This is equivalent to the C++ class `alloc_slice`.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLSliceResult {
    pub buf: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_FLSliceResult() {
    assert_eq!(
        ::core::mem::size_of::<FLSliceResult>(),
        16usize,
        concat!("Size of: ", stringify!(FLSliceResult))
    );
    assert_eq!(
        ::core::mem::align_of::<FLSliceResult>(),
        8usize,
        concat!("Alignment of ", stringify!(FLSliceResult))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLSliceResult>())).buf as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FLSliceResult), "::", stringify!(buf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<FLSliceResult>())).size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(FLSliceResult), "::", stringify!(size))
    );
}
pub type FLString = FLSlice;
pub type FLStringResult = FLSliceResult;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLValue {
    _unused: [u8; 0],
}
pub type FLValue = *const _FLValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLArray {
    _unused: [u8; 0],
}
pub type FLArray = *const _FLArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLDict {
    _unused: [u8; 0],
}
pub type FLDict = *const _FLDict;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLSlot {
    _unused: [u8; 0],
}
pub type FLSlot = *mut _FLSlot;
pub type FLMutableArray = *mut _FLArray;
pub type FLMutableDict = *mut _FLDict;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLDoc {
    _unused: [u8; 0],
}
pub type FLDoc = *mut _FLDoc;
extern "C" {
    #[doc = " Encodes a Fleece value as JSON (or a JSON fragment.)"]
    #[doc = "Any Data values will become base64-encoded JSON strings."]
    pub fn FLValue_ToJSON(arg1: FLValue) -> FLStringResult;
}
#[doc = "< Type of a NULL pointer, i.e. no such value, like JSON `undefined`. Also the type of a value created by FLEncoder_WriteUndefined()."]
pub const kFLUndefined: FLValueType = -1;
#[doc = "< Equivalent to a JSON 'null'"]
pub const kFLNull: FLValueType = 0;
#[doc = "< A `true` or `false` value"]
pub const kFLBoolean: FLValueType = 1;
#[doc = "< A numeric value, either integer or floating-point"]
pub const kFLNumber: FLValueType = 2;
#[doc = "< A string"]
pub const kFLString: FLValueType = 3;
#[doc = "< Binary data (no JSON equivalent)"]
pub const kFLData: FLValueType = 4;
#[doc = "< An array of values"]
pub const kFLArray: FLValueType = 5;
#[doc = "< A mapping of strings to values"]
pub const kFLDict: FLValueType = 6;
#[doc = " Types of Fleece values. Basically JSON, with the addition of Data (raw blob)."]
pub type FLValueType = i32;
extern "C" {
    #[doc = " Returns the data type of an arbitrary Value."]
    #[doc = "(If the parameter is a NULL pointer, returns `kFLUndefined`.)"]
    pub fn FLValue_GetType(arg1: FLValue) -> FLValueType;
}
extern "C" {
    #[doc = " Returns the exact contents of a string value, or null for all other types."]
    pub fn FLValue_AsString(arg1: FLValue) -> FLString;
}
extern "C" {
    #[doc = " VALUE SLOT"]
    pub fn FLSlot_SetNull(arg1: FLSlot);
}
extern "C" {
    pub fn FLSlot_SetBool(arg1: FLSlot, arg2: bool);
}
extern "C" {
    pub fn FLSlot_SetInt(arg1: FLSlot, arg2: i64);
}
extern "C" {
    pub fn FLSlot_SetString(arg1: FLSlot, arg2: FLString);
}
extern "C" {
    pub fn FLSlot_SetData(arg1: FLSlot, arg2: FLSlice);
}
extern "C" {
    pub fn FLSlot_SetValue(arg1: FLSlot, arg2: FLValue);
}
extern "C" {
    #[doc = " Returns true if a dictionary is empty (or NULL). Depending on the dictionary's"]
    #[doc = "representation, this can be faster than `FLDict_Count(a) == 0`"]
    pub fn FLDict_IsEmpty(arg1: FLDict) -> bool;
}
extern "C" {
    #[doc = " If the dictionary is mutable, returns it cast to FLMutableDict, else NULL."]
    pub fn FLDict_AsMutable(arg1: FLDict) -> FLMutableDict;
}
extern "C" {
    #[doc = " Looks up a key in a dictionary, returning its value."]
    #[doc = "Returns NULL if the value is not found or if the dictionary is NULL."]
    pub fn FLDict_Get(arg1: FLDict, keyString: FLSlice) -> FLValue;
}
extern "C" {
    #[doc = " Returns the Slot storing the key's value, adding a new one if needed (with a null value.)"]
    #[doc = "To set the value itself, call one of the FLSlot functions, e.g. \\ref FLSlot_SetInt."]
    pub fn FLMutableDict_Set(FL_NONNULL: FLMutableDict, key: FLString) -> FLSlot;
}
#[doc = " Conflict-handling options when saving or deleting a document."]
pub type CBLConcurrencyControl = u8;
extern "C" {
    #[doc = " Reads a document from the database, creating a new (immutable) \\ref CBLDocument object."]
    #[doc = "Each call to this function creates a new object (which must later be released.)"]
    #[doc = "@note  If you are reading the document in order to make changes to it, call"]
    #[doc = "\\ref CBLDatabase_GetMutableDocument instead."]
    #[doc = "@param database  The database."]
    #[doc = "@param docID  The ID of the document."]
    #[doc = "@return  A new \\ref CBLDocument instance, or NULL if no document with that ID exists."]
    pub fn CBLDatabase_GetDocument(database: *const CBLDatabase, docID: *const ::std::os::raw::c_char) -> *const CBLDocument;
}
extern "C" {
    #[doc = " Saves a (mutable) document to the database."]
    #[doc = "@param db  The database to save to."]
    #[doc = "@param doc  The mutable document to save."]
    #[doc = "@param concurrency  Conflict-handling strategy."]
    #[doc = "@param error  On failure, the error will be written here."]
    #[doc = "@return  An updated document reflecting the saved changes, or NULL on failure."]
    pub fn CBLDatabase_SaveDocument(
        db: *mut CBLDatabase,
        doc: *mut CBLDocument,
        concurrency: CBLConcurrencyControl,
        error: *mut CBLError,
    ) -> *const CBLDocument;
}
extern "C" {
    #[doc = " Deletes a document from the database. Deletions are replicated."]
    #[doc = "@warning  You are still responsible for releasing the CBLDocument."]
    #[doc = "@param document  The document to delete."]
    #[doc = "@param concurrency  Conflict-handling strategy."]
    #[doc = "@param error  On failure, the error will be written here."]
    #[doc = "@return  True if the document was deleted, false if an error occurred."]
    pub fn CBLDocument_Delete(document: *const CBLDocument, concurrency: CBLConcurrencyControl, error: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Purges a document. This removes all traces of the document from the database."]
    #[doc = "Purges are _not_ replicated. If the document is changed on a server, it will be re-created"]
    #[doc = "when pulled."]
    #[doc = "@warning  You are still responsible for releasing the \\ref CBLDocument reference."]
    #[doc = "@note If you don't have the document in memory already, \\ref CBLDatabase_PurgeDocumentByID is a"]
    #[doc = "simpler shortcut."]
    #[doc = "@param document  The document to delete."]
    #[doc = "@param error  On failure, the error will be written here."]
    #[doc = "@return  True if the document was purged, false if it doesn't exist or the purge failed."]
    pub fn CBLDocument_Purge(document: *const CBLDocument, error: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Purges a document, given only its ID."]
    #[doc = "@note  If no document with that ID exists, this function will return false but the error"]
    #[doc = "code will be zero."]
    #[doc = "@param database  The database."]
    #[doc = "@param docID  The document ID to purge."]
    #[doc = "@param error  On failure, the error will be written here."]
    #[doc = "@return  True if the document was purged, false if it doesn't exist or the purge failed."]
    pub fn CBLDatabase_PurgeDocumentByID(database: *mut CBLDatabase, docID: *const ::std::os::raw::c_char, error: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Reads a document from the database, in mutable form that can be updated and saved."]
    #[doc = "(This function is otherwise identical to \\ref CBLDatabase_GetDocument.)"]
    #[doc = "@note  You must release the document when you're done with it."]
    #[doc = "@param database  The database."]
    #[doc = "@param docID  The ID of the document."]
    #[doc = "@return  A new mutable CBLDocument instance, or NULL if no document with that ID exists."]
    pub fn CBLDatabase_GetMutableDocument(database: *mut CBLDatabase, docID: *const ::std::os::raw::c_char) -> *mut CBLDocument;
}
extern "C" {
    #[doc = " Creates a new, empty document in memory. It will not be added to a database until saved."]
    #[doc = "@param docID  The ID of the new document, or NULL to assign a new unique ID."]
    #[doc = "@return  The mutable document instance."]
    pub fn CBLDocument_New(docID: *const ::std::os::raw::c_char) -> *mut CBLDocument;
}
extern "C" {
    #[doc = " Creates a new mutable CBLDocument instance that refers to the same document as the original."]
    #[doc = "If the original document has unsaved changes, the new one will also start out with the same"]
    #[doc = "changes; but mutating one document thereafter will not affect the other."]
    #[doc = "@note  You must release the new reference when you're done with it."]
    pub fn CBLDocument_MutableCopy(original: *const CBLDocument) -> *mut CBLDocument;
}
extern "C" {
    #[doc = " Returns a document's ID."]
    pub fn CBLDocument_ID(arg1: *const CBLDocument) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a document's current sequence in the local database."]
    #[doc = "This number increases every time the document is saved, and a more recently saved document"]
    #[doc = "will have a greater sequence number than one saved earlier, so sequences may be used as an"]
    #[doc = "abstract 'clock' to tell relative modification times."]
    pub fn CBLDocument_Sequence(arg1: *const CBLDocument) -> u64;
}
extern "C" {
    #[doc = " Returns a document's properties as a dictionary."]
    #[doc = "@note  The dictionary object is owned by the document; you do not need to release it."]
    #[doc = "@warning  This dictionary _reference_ is immutable, but if the document is mutable the"]
    #[doc = "underlying dictionary itself is mutable and could be modified through a mutable"]
    #[doc = "reference obtained via \\ref CBLDocument_MutableProperties. If you need to preserve the"]
    #[doc = "properties, call \\ref FLDict_MutableCopy to make a deep copy."]
    pub fn CBLDocument_Properties(arg1: *const CBLDocument) -> FLDict;
}
extern "C" {
    #[doc = " Returns a mutable document's properties as a mutable dictionary."]
    #[doc = "You may modify this dictionary and then call \\ref CBLDatabase_SaveDocument to persist the changes."]
    #[doc = "@note  The dictionary object is owned by the document; you do not need to release it."]
    #[doc = "@note  Every call to this function returns the same mutable collection. This is the"]
    #[doc = "same collection returned by \\ref CBLDocument_Properties."]
    pub fn CBLDocument_MutableProperties(arg1: *mut CBLDocument) -> FLMutableDict;
}
extern "C" {
    #[doc = " Sets a mutable document's properties."]
    #[doc = "Call \\ref CBLDatabase_SaveDocument to persist the changes."]
    #[doc = "@note  The dictionary object will be retained by the document. You are responsible for"]
    #[doc = "releasing your own reference(s) to it."]
    pub fn CBLDocument_SetProperties(arg1: *mut CBLDocument, properties: FLMutableDict);
}
extern "C" {
    pub fn CBLDocument_CreateFleeceDoc(arg1: *const CBLDocument) -> FLDoc;
}
extern "C" {
    #[doc = " Returns a document's properties as a null-terminated JSON string."]
    #[doc = "@note You are responsible for calling `free()` on the returned string."]
    pub fn CBLDocument_PropertiesAsJSON(arg1: *const CBLDocument) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets a mutable document's properties from a JSON string."]
    pub fn CBLDocument_SetPropertiesAsJSON(arg1: *mut CBLDocument, json: *const ::std::os::raw::c_char, arg2: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Returns the time, if any, at which a given document will expire and be purged."]
    #[doc = "Documents don't normally expire; you have to call \\ref CBLDatabase_SetDocumentExpiration"]
    #[doc = "to set a document's expiration time."]
    #[doc = "@param db  The database."]
    #[doc = "@param docID  The ID of the document."]
    #[doc = "@param error  On failure, an error is written here."]
    #[doc = "@return  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),"]
    #[doc = "or 0 if the document does not have an expiration,"]
    #[doc = "or -1 if the call failed."]
    pub fn CBLDatabase_GetDocumentExpiration(db: *mut CBLDatabase, docID: *const ::std::os::raw::c_char, error: *mut CBLError) -> CBLTimestamp;
}
extern "C" {
    #[doc = " Sets or clears the expiration time of a document."]
    #[doc = "@note  The purging of expired documents is not yet automatic; you will need to call"]
    #[doc = "\\ref CBLDatabase_PurgeExpiredDocuments when the time comes, to make it happen."]
    #[doc = "@param db  The database."]
    #[doc = "@param docID  The ID of the document."]
    #[doc = "@param expiration  The expiration time as a CBLTimestamp (milliseconds since Unix epoch),"]
    #[doc = "or 0 if the document should never expire."]
    #[doc = "@param error  On failure, an error is written here."]
    #[doc = "@return  True on success, false on failure."]
    pub fn CBLDatabase_SetDocumentExpiration(
        db: *mut CBLDatabase,
        docID: *const ::std::os::raw::c_char,
        expiration: CBLTimestamp,
        error: *mut CBLError,
    ) -> bool;
}
#[doc = " A document change listener callback, invoked after a specific document is changed on disk."]
#[doc = "@warning  By default, this listener may be called on arbitrary threads. If your code isn't"]
#[doc = "prepared for that, you may want to use \\ref CBLDatabase_BufferNotifications"]
#[doc = "so that listeners will be called in a safe context."]
#[doc = "@param context  An arbitrary value given when the callback was registered."]
#[doc = "@param db  The database containing the document."]
#[doc = "@param docID  The document's ID."]
pub type CBLDocumentChangeListener =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, db: *const CBLDatabase, docID: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Registers a document change listener callback. It will be called after a specific document"]
    #[doc = "is changed on disk."]
    #[doc = "@param db  The database to observe."]
    #[doc = "@param docID  The ID of the document to observe."]
    #[doc = "@param listener  The callback to be invoked."]
    #[doc = "@param context  An opaque value that will be passed to the callback."]
    #[doc = "@return  A token to be passed to \\ref CBLListener_Remove when it's time to remove the"]
    #[doc = "listener."]
    pub fn CBLDatabase_AddDocumentChangeListener(
        db: *const CBLDatabase,
        docID: *const ::std::os::raw::c_char,
        listener: CBLDocumentChangeListener,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut CBLListenerToken;
}
extern "C" {
    #[doc = " Returns a CBLBlob object corresponding to a blob dictionary in a document."]
    #[doc = "@param blobDict  A dictionary in a document."]
    #[doc = "@return  A CBLBlob instance for this blob, or NULL if the dictionary is not a blob."]
    pub fn CBLBlob_Get(blobDict: FLDict) -> *const CBLBlob;
}
extern "C" {
    #[doc = " Returns the length in bytes of a blob's content (from its `length` property)."]
    pub fn CBLBlob_Length(arg1: *const CBLBlob) -> u64;
}
extern "C" {
    #[doc = " Returns the cryptographic digest of a blob's content (from its `digest` property)."]
    pub fn CBLBlob_Digest(arg1: *const CBLBlob) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a blob's MIME type, if its metadata has a `content_type` property."]
    pub fn CBLBlob_ContentType(arg1: *const CBLBlob) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a blob's metadata. This includes the `digest`, `length` and `content_type`"]
    #[doc = "properties, as well as any custom ones that may have been added."]
    pub fn CBLBlob_Properties(arg1: *const CBLBlob) -> FLDict;
}
extern "C" {
    #[doc = " Reads the blob's contents into memory and returns them."]
    #[doc = "You are responsible for calling \\ref FLSliceResult_Free on the returned data when done."]
    #[doc = "@warning  This can potentially allocate a very large heap block!"]
    pub fn CBLBlob_LoadContent(arg1: *const CBLBlob, outError: *mut CBLError) -> FLSliceResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLBlobReadStream {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Opens a stream for reading a blob's content."]
    pub fn CBLBlob_OpenContentStream(arg1: *const CBLBlob, outError: *mut CBLError) -> *mut CBLBlobReadStream;
}
extern "C" {
    #[doc = " Creates a new blob given its contents as a single block of data."]
    #[doc = "@note  You are responsible for releasing the \\ref CBLBlob, but not until after its document"]
    #[doc = "has been saved."]
    #[doc = "@param contentType  The MIME type (optional)."]
    #[doc = "@param contents  The data's address and length."]
    #[doc = "@return  A new CBLBlob instance."]
    pub fn CBLBlob_CreateWithData(contentType: *const ::std::os::raw::c_char, contents: FLSlice) -> *mut CBLBlob;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLBlobWriteStream {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates a new blob after its data has been written to a \\ref CBLBlobWriteStream."]
    #[doc = "You should then add the blob to a mutable document as a property -- see"]
    #[doc = "\\ref FLMutableDict_SetBlob and \\ref FLMutableArray_SetBlob."]
    #[doc = "@note  You are responsible for releasing the CBLBlob reference."]
    #[doc = "@note  Do not free the stream; the blob will do that."]
    #[doc = "@param contentType  The MIME type (optional)."]
    #[doc = "@param writer  The blob-writing stream the data was written to."]
    #[doc = "@return  A new CBLBlob instance."]
    pub fn CBLBlob_CreateWithStream(contentType: *const ::std::os::raw::c_char, writer: *mut CBLBlobWriteStream) -> *mut CBLBlob;
}
#[doc = " Query languages"]
pub type CBLQueryLanguage = u32;
extern "C" {
    #[doc = " Creates a new query by compiling the input string."]
    #[doc = "This is fast, but not instantaneous. If you need to run the same query many times, keep the"]
    #[doc = "\\ref CBLQuery around instead of compiling it each time. If you need to run related queries"]
    #[doc = "with only some values different, create one query with placeholder parameter(s), and substitute"]
    #[doc = "the desired value(s) with \\ref CBLQuery_SetParameters each time you run the query."]
    #[doc = "@note  You must release the \\ref CBLQuery when you're finished with it."]
    #[doc = "@param db  The database to query."]
    #[doc = "@param language  The query language,"]
    #[doc = "[JSON](https://github.com/couchbase/couchbase-lite-core/wiki/JSON-Query-Schema) or"]
    #[doc = "[N1QL](https://docs.couchbase.com/server/4.0/n1ql/n1ql-language-reference/index.html)."]
    #[doc = "@param queryString  The query string."]
    #[doc = "@param outErrorPos  If non-NULL, then on a parse error the approximate byte offset in the"]
    #[doc = "input expression will be stored here (or -1 if not known/applicable.)"]
    #[doc = "@param error  On failure, the error will be written here."]
    #[doc = "@return  The new query object."]
    pub fn CBLQuery_New(
        db: *const CBLDatabase,
        language: CBLQueryLanguage,
        queryString: *const ::std::os::raw::c_char,
        outErrorPos: *mut ::std::os::raw::c_int,
        error: *mut CBLError,
    ) -> *mut CBLQuery;
}
extern "C" {
    #[doc = " Assigns values to the query's parameters."]
    #[doc = "These values will be substited for those parameters whenever the query is executed,"]
    #[doc = "until they are next assigned."]
    #[doc = ""]
    #[doc = "Parameters are specified in the query source as"]
    #[doc = "e.g. `$PARAM` (N1QL) or `[\"$PARAM\"]` (JSON). In this example, the `parameters` dictionary"]
    #[doc = "to this call should have a key `PARAM` that maps to the value of the parameter."]
    #[doc = "@param query  The query."]
    #[doc = "@param parameters  The parameters in the form of a Fleece \\ref FLDict \"dictionary\" whose"]
    #[doc = "keys are the parameter names. (It's easiest to construct this by using the mutable"]
    #[doc = "API, i.e. calling \\ref FLMutableDict_New and adding keys/values.)"]
    pub fn CBLQuery_SetParameters(query: *mut CBLQuery, parameters: FLDict);
}
extern "C" {
    #[doc = " Returns the query's current parameter bindings, if any."]
    pub fn CBLQuery_Parameters(query: *mut CBLQuery) -> FLDict;
}
extern "C" {
    #[doc = " Assigns values to the query's parameters, from JSON data."]
    #[doc = "See \\ref CBLQuery_SetParameters for details."]
    #[doc = "@param query  The query."]
    #[doc = "@param json  The parameters in the form of a JSON-encoded object whose"]
    #[doc = "keys are the parameter names. (You may use JSON5 syntax.)"]
    pub fn CBLQuery_SetParametersAsJSON(query: *mut CBLQuery, json: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Runs the query, returning the results."]
    #[doc = "To obtain the results you'll typically call \\ref CBLResultSet_Next in a `while` loop,"]
    #[doc = "examining the values in the \\ref CBLResultSet each time around."]
    #[doc = "@note  You must release the result set when you're finished with it."]
    pub fn CBLQuery_Execute(arg1: *mut CBLQuery, arg2: *mut CBLError) -> *mut CBLResultSet;
}
extern "C" {
    #[doc = " Returns information about the query, including the translated SQLite form, and the search"]
    #[doc = "strategy. You can use this to help optimize the query: the word `SCAN` in the strategy"]
    #[doc = "indicates a linear scan of the entire database, which should be avoided by adding an index."]
    #[doc = "The strategy will also show which index(es), if any, are used."]
    pub fn CBLQuery_Explain(arg1: *mut CBLQuery) -> FLSliceResult;
}
extern "C" {
    #[doc = " Returns the number of columns in each result."]
    pub fn CBLQuery_ColumnCount(arg1: *mut CBLQuery) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns the name of a column in the result."]
    #[doc = "The column name is based on its expression in the `SELECT...` or `WHAT:` section of the"]
    #[doc = "query. A column that returns a property or property path will be named after that property."]
    #[doc = "A column that returns an expression will have an automatically-generated name like `$1`."]
    #[doc = "To give a column a custom name, use the `AS` syntax in the query."]
    pub fn CBLQuery_ColumnName(arg1: *mut CBLQuery, columnIndex: ::std::os::raw::c_uint) -> FLSlice;
}
extern "C" {
    #[doc = " Moves the result-set iterator to the next result."]
    #[doc = "Returns false if there are no more results."]
    #[doc = "@warning This must be called _before_ examining the first result."]
    pub fn CBLResultSet_Next(arg1: *mut CBLResultSet) -> bool;
}
extern "C" {
    #[doc = " Returns the value of a column of the current result, given its (zero-based) numeric index."]
    #[doc = "This may return a NULL pointer, indicating `MISSING`, if the value doesn't exist, e.g. if"]
    #[doc = "the column is a property that doesn't exist in the document."]
    pub fn CBLResultSet_ValueAtIndex(arg1: *mut CBLResultSet, index: ::std::os::raw::c_uint) -> FLValue;
}
extern "C" {
    #[doc = " Returns the value of a column of the current result, given its name."]
    #[doc = "This may return a NULL pointer, indicating `MISSING`, if the value doesn't exist, e.g. if"]
    #[doc = "the column is a property that doesn't exist in the document. (Or, of course, if the key"]
    #[doc = "is not a column name in this query.)"]
    #[doc = "@note  See \\ref CBLQuery_ColumnName for a discussion of column names."]
    pub fn CBLResultSet_ValueForKey(arg1: *mut CBLResultSet, key: *const ::std::os::raw::c_char) -> FLValue;
}
#[doc = " A callback to be invoked after the query's results have changed."]
#[doc = "The actual result set can be obtained by calling \\ref CBLQuery_CurrentResults, either during"]
#[doc = "the callback or at any time thereafter."]
#[doc = "@warning  By default, this listener may be called on arbitrary threads. If your code isn't"]
#[doc = "prepared for that, you may want to use \\ref CBLDatabase_BufferNotifications"]
#[doc = "so that listeners will be called in a safe context."]
#[doc = "@param context  The same `context` value that you passed when adding the listener."]
#[doc = "@param query  The query that triggered the listener."]
pub type CBLQueryChangeListener = ::core::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, query: *mut CBLQuery)>;
extern "C" {
    #[doc = " Registers a change listener callback with a query, turning it into a \"live query\" until"]
    #[doc = "the listener is removed (via \\ref CBLListener_Remove)."]
    #[doc = ""]
    #[doc = "When the first change listener is added, the query will run (in the background) and notify"]
    #[doc = "the listener(s) of the results when ready. After that, it will run in the background after"]
    #[doc = "the database changes, and only notify the listeners when the result set changes."]
    #[doc = "@param query  The query to observe."]
    #[doc = "@param listener  The callback to be invoked."]
    #[doc = "@param context  An opaque value that will be passed to the callback."]
    #[doc = "@return  A token to be passed to \\ref CBLListener_Remove when it's time to remove the"]
    #[doc = "listener."]
    pub fn CBLQuery_AddChangeListener(
        query: *mut CBLQuery,
        listener: CBLQueryChangeListener,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut CBLListenerToken;
}
extern "C" {
    #[doc = " Returns the query's _entire_ current result set, after it's been announced via a call to the"]
    #[doc = "listener's callback."]
    #[doc = "The returned object is valid until the next call to \\ref CBLQuery_CurrentResults (with the"]
    #[doc = "same query and listener) or until you free the listener. If you need to keep it alive longer,"]
    #[doc = "retain it yourself."]
    #[doc = "@param query  The query being listened to."]
    #[doc = "@param listener  The query listener that was notified."]
    #[doc = "@param error  If the query failed to run, the error will be stored here."]
    #[doc = "@return  The query's current result set, or NULL if the query failed to run."]
    pub fn CBLQuery_CurrentResults(query: *mut CBLQuery, listener: *mut CBLListenerToken, error: *mut CBLError) -> *mut CBLResultSet;
}
#[doc = " Types of database indexes."]
pub type CBLIndexType = u32;
#[doc = " Parameters for creating a database index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLIndexSpec {
    #[doc = " The type of index to create."]
    pub type_: CBLIndexType,
    #[doc = " A JSON array describing each column of the index."]
    pub keyExpressionsJSON: *const ::std::os::raw::c_char,
    #[doc = " In a full-text index, should diacritical marks (accents) be ignored?"]
    #[doc = "Defaults to false. Generally this should be left `false` for non-English text."]
    pub ignoreAccents: bool,
    #[doc = " In a full-text index, the dominant language. Setting this enables word stemming, i.e."]
    #[doc = "matching different cases of the same word (\"big\" and \"bigger\", for instance) and ignoring"]
    #[doc = "common \"stop-words\" (\"the\", \"a\", \"of\", etc.)"]
    #[doc = ""]
    #[doc = "Can be an ISO-639 language code or a lowercase (English) language name; supported"]
    #[doc = "languages are: da/danish, nl/dutch, en/english, fi/finnish, fr/french, de/german,"]
    #[doc = "hu/hungarian, it/italian, no/norwegian, pt/portuguese, ro/romanian, ru/russian,"]
    #[doc = "es/spanish, sv/swedish, tr/turkish."]
    #[doc = ""]
    #[doc = "If left null,  or set to an unrecognized language, no language-specific behaviors"]
    #[doc = "such as stemming and stop-word removal occur."]
    pub language: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CBLIndexSpec() {
    assert_eq!(
        ::core::mem::size_of::<CBLIndexSpec>(),
        32usize,
        concat!("Size of: ", stringify!(CBLIndexSpec))
    );
    assert_eq!(
        ::core::mem::align_of::<CBLIndexSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(CBLIndexSpec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLIndexSpec>())).type_ as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CBLIndexSpec), "::", stringify!(type_))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLIndexSpec>())).keyExpressionsJSON as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CBLIndexSpec), "::", stringify!(keyExpressionsJSON))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLIndexSpec>())).ignoreAccents as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(CBLIndexSpec), "::", stringify!(ignoreAccents))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLIndexSpec>())).language as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(CBLIndexSpec), "::", stringify!(language))
    );
}
extern "C" {
    #[doc = " Creates a database index."]
    #[doc = "Indexes are persistent."]
    #[doc = "If an identical index with that name already exists, nothing happens (and no error is returned.)"]
    #[doc = "If a non-identical index with that name already exists, it is deleted and re-created."]
    pub fn CBLDatabase_CreateIndex(db: *mut CBLDatabase, name: *const ::std::os::raw::c_char, arg1: CBLIndexSpec, outError: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Deletes an index given its name."]
    pub fn CBLDatabase_DeleteIndex(db: *mut CBLDatabase, name: *const ::std::os::raw::c_char, outError: *mut CBLError) -> bool;
}
extern "C" {
    #[doc = " Returns the names of the indexes on this database, as an array of strings."]
    #[doc = "@note  You are responsible for releasing the returned Fleece array."]
    pub fn CBLDatabase_IndexNames(db: *mut CBLDatabase) -> FLMutableArray;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLEndpoint {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates a new endpoint representing a server-based database at the given URL."]
    #[doc = "The URL's scheme must be `ws` or `wss`, it must of course have a valid hostname,"]
    #[doc = "and its path must be the name of the database on that server."]
    #[doc = "The port can be omitted; it defaults to 80 for `ws` and 443 for `wss`."]
    #[doc = "For example: `wss://example.org/dbname`"]
    pub fn CBLEndpoint_NewWithURL(url: *const ::std::os::raw::c_char) -> *mut CBLEndpoint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLAuthenticator {
    _unused: [u8; 0],
}
#[doc = " Direction of replication: push, pull, or both."]
pub type CBLReplicatorType = u8;
#[doc = " A callback that can decide whether a particular document should be pushed or pulled."]
#[doc = "@warning  This callback will be called on a background thread managed by the replicator."]
#[doc = "It must pay attention to thread-safety. It should not take a long time to return,"]
#[doc = "or it will slow down the replicator."]
pub type CBLReplicationFilter =
    ::core::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, document: *mut CBLDocument, isDeleted: bool) -> bool>;
#[doc = " The configuration of a replicator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLReplicatorConfiguration {
    #[doc = "< The database to replicate"]
    pub database: *mut CBLDatabase,
    #[doc = "< The address of the other database to replicate with"]
    pub endpoint: *mut CBLEndpoint,
    #[doc = "< Push, pull or both"]
    pub replicatorType: CBLReplicatorType,
    #[doc = "< Continuous replication?"]
    pub continuous: bool,
    #[doc = "< Authentication credentials, if needed"]
    pub authenticator: *mut CBLAuthenticator,
    #[doc = "< An X.509 cert to \"pin\" TLS connections to"]
    pub pinnedServerCertificate: FLSlice,
    #[doc = "< Extra HTTP headers to add to the WebSocket request"]
    pub headers: FLDict,
    #[doc = "< Optional set of channels to pull from"]
    pub channels: FLArray,
    #[doc = "< Optional set of document IDs to replicate"]
    pub documentIDs: FLArray,
    #[doc = "< Optional callback to filter which docs are pushed"]
    pub pushFilter: CBLReplicationFilter,
    #[doc = "< Optional callback to validate incoming docs"]
    pub pullFilter: CBLReplicationFilter,
    #[doc = "< Arbitrary value passed to filter callbacks"]
    pub filterContext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CBLReplicatorConfiguration() {
    assert_eq!(
        ::core::mem::size_of::<CBLReplicatorConfiguration>(),
        96usize,
        concat!("Size of: ", stringify!(CBLReplicatorConfiguration))
    );
    assert_eq!(
        ::core::mem::align_of::<CBLReplicatorConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(CBLReplicatorConfiguration))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).database as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorConfiguration), "::", stringify!(database))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).endpoint as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorConfiguration), "::", stringify!(endpoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).replicatorType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLReplicatorConfiguration),
            "::",
            stringify!(replicatorType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).continuous as *const _ as usize },
        17usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorConfiguration), "::", stringify!(continuous))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).authenticator as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLReplicatorConfiguration),
            "::",
            stringify!(authenticator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).pinnedServerCertificate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLReplicatorConfiguration),
            "::",
            stringify!(pinnedServerCertificate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).headers as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorConfiguration), "::", stringify!(headers))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).channels as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorConfiguration), "::", stringify!(channels))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).documentIDs as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorConfiguration), "::", stringify!(documentIDs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).pushFilter as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorConfiguration), "::", stringify!(pushFilter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).pullFilter as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorConfiguration), "::", stringify!(pullFilter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorConfiguration>())).filterContext as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CBLReplicatorConfiguration),
            "::",
            stringify!(filterContext)
        )
    );
}
extern "C" {
    #[doc = " Creates a replicator with the given configuration."]
    pub fn CBLReplicator_New(arg1: *const CBLReplicatorConfiguration, arg2: *mut CBLError) -> *mut CBLReplicator;
}
extern "C" {
    #[doc = " Returns the configuration of an existing replicator."]
    pub fn CBLReplicator_Config(arg1: *mut CBLReplicator) -> *const CBLReplicatorConfiguration;
}
extern "C" {
    #[doc = " Instructs the replicator to ignore existing checkpoints the next time it runs."]
    #[doc = "This will cause it to scan through all the documents on the remote database, which takes"]
    #[doc = "a lot longer, but it can resolve problems with missing documents if the client and"]
    #[doc = "server have gotten out of sync somehow."]
    pub fn CBLReplicator_ResetCheckpoint(arg1: *mut CBLReplicator);
}
extern "C" {
    #[doc = " Starts a replicator, asynchronously. Does nothing if it's already started."]
    pub fn CBLReplicator_Start(arg1: *mut CBLReplicator);
}
extern "C" {
    #[doc = " Stops a running replicator, asynchronously. Does nothing if it's not already started."]
    #[doc = "The replicator will call your \\ref CBLReplicatorChangeListener with an activity level of"]
    #[doc = "\\ref kCBLReplicatorStopped after it stops. Until then, consider it still active."]
    pub fn CBLReplicator_Stop(arg1: *mut CBLReplicator);
}
#[doc = " The possible states a replicator can be in during its lifecycle."]
pub type CBLReplicatorActivityLevel = u8;
#[doc = " A fractional progress value. The units are undefined; the only meaningful number is the"]
#[doc = "(fractional) result of `completed` \u{f7} `total`, which will range from 0.0 to 1.0."]
#[doc = "Before anything happens, both `completed` and `total` will be 0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLReplicatorProgress {
    pub fractionComplete: f32,
    #[doc = "< Number of documents transferred so far"]
    pub documentCount: u64,
}
#[test]
fn bindgen_test_layout_CBLReplicatorProgress() {
    assert_eq!(
        ::core::mem::size_of::<CBLReplicatorProgress>(),
        16usize,
        concat!("Size of: ", stringify!(CBLReplicatorProgress))
    );
    assert_eq!(
        ::core::mem::align_of::<CBLReplicatorProgress>(),
        8usize,
        concat!("Alignment of ", stringify!(CBLReplicatorProgress))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorProgress>())).fractionComplete as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorProgress), "::", stringify!(fractionComplete))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorProgress>())).documentCount as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorProgress), "::", stringify!(documentCount))
    );
}
#[doc = " A replicator's current status."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLReplicatorStatus {
    #[doc = "< Current state"]
    pub activity: CBLReplicatorActivityLevel,
    #[doc = "< Approximate fraction complete"]
    pub progress: CBLReplicatorProgress,
    #[doc = "< Error, if any"]
    pub error: CBLError,
}
#[test]
fn bindgen_test_layout_CBLReplicatorStatus() {
    assert_eq!(
        ::core::mem::size_of::<CBLReplicatorStatus>(),
        40usize,
        concat!("Size of: ", stringify!(CBLReplicatorStatus))
    );
    assert_eq!(
        ::core::mem::align_of::<CBLReplicatorStatus>(),
        8usize,
        concat!("Alignment of ", stringify!(CBLReplicatorStatus))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorStatus>())).activity as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorStatus), "::", stringify!(activity))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorStatus>())).progress as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorStatus), "::", stringify!(progress))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatorStatus>())).error as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(CBLReplicatorStatus), "::", stringify!(error))
    );
}
extern "C" {
    #[doc = " Returns the replicator's current status."]
    pub fn CBLReplicator_Status(arg1: *mut CBLReplicator) -> CBLReplicatorStatus;
}
#[doc = " A callback that notifies you when the replicator's status changes."]
#[doc = "@warning  This callback will be called on a background thread managed by the replicator."]
#[doc = "It must pay attention to thread-safety. It should not take a long time to return,"]
#[doc = "or it will slow down the replicator."]
#[doc = "@param context  The value given when the listener was added."]
#[doc = "@param replicator  The replicator."]
#[doc = "@param status  The replicator's status."]
pub type CBLReplicatorChangeListener = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, replicator: *mut CBLReplicator, status: *const CBLReplicatorStatus),
>;
extern "C" {
    #[doc = " Adds a listener that will be called when the replicator's status changes."]
    #[doc = "@warning UNIMPLEMENTED!"]
    pub fn CBLReplicator_AddChangeListener(
        arg1: *mut CBLReplicator,
        arg2: CBLReplicatorChangeListener,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut CBLListenerToken;
}
#[doc = " Flags describing a replicated document."]
pub type CBLDocumentFlags = ::std::os::raw::c_uint;
#[doc = " Information about a document that's been pushed or pulled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBLReplicatedDocument {
    #[doc = "< The document ID"]
    pub ID: *const ::std::os::raw::c_char,
    #[doc = "< Indicates whether the document was deleted or removed"]
    pub flags: CBLDocumentFlags,
    #[doc = "< If the code is nonzero, the document failed to replicate."]
    pub error: CBLError,
}
#[test]
fn bindgen_test_layout_CBLReplicatedDocument() {
    assert_eq!(
        ::core::mem::size_of::<CBLReplicatedDocument>(),
        24usize,
        concat!("Size of: ", stringify!(CBLReplicatedDocument))
    );
    assert_eq!(
        ::core::mem::align_of::<CBLReplicatedDocument>(),
        8usize,
        concat!("Alignment of ", stringify!(CBLReplicatedDocument))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatedDocument>())).ID as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CBLReplicatedDocument), "::", stringify!(ID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatedDocument>())).flags as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CBLReplicatedDocument), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CBLReplicatedDocument>())).error as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(CBLReplicatedDocument), "::", stringify!(error))
    );
}
#[doc = " A callback that notifies you when documents are replicated."]
#[doc = "@warning  This callback will be called on a background thread managed by the replicator."]
#[doc = "It must pay attention to thread-safety. It should not take a long time to return,"]
#[doc = "or it will slow down the replicator."]
#[doc = "@param context  The value given when the listener was added."]
#[doc = "@param replicator  The replicator."]
#[doc = "@param isPush  True if the document(s) were pushed, false if pulled."]
#[doc = "@param numDocuments  The number of documents reported by this callback."]
#[doc = "@param documents  An array with information about each document."]
pub type CBLReplicatedDocumentListener = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        replicator: *mut CBLReplicator,
        isPush: bool,
        numDocuments: ::std::os::raw::c_uint,
        documents: *const CBLReplicatedDocument,
    ),
>;
extern "C" {
    #[doc = " Adds a listener that will be called when documents are replicated."]
    #[doc = "@warning UNIMPLEMENTED!"]
    pub fn CBLReplicator_AddDocumentListener(
        arg1: *mut CBLReplicator,
        arg2: CBLReplicatedDocumentListener,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut CBLListenerToken;
}
